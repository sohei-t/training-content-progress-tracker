# ワークフロー記憶保持メカニズム

## 📌 メインエージェントが各フェーズで必ず出力する内容

### フェーズ開始時の標準出力フォーマット

```
=====================================
📌 ワークフロー再確認 [フェーズ名]
=====================================
プロジェクト: {プロジェクト名}
現在フェーズ: {フェーズ番号}/{全フェーズ数} - {フェーズ名}
作業環境: ./worktrees/mission-{プロジェクト名}/

【品質基準】
✓ テストカバレッジ: 80%以上
✓ 改善ループ: 最大3回
✓ エラーフリー動作

【実行ルール】
✓ 並列実行: 1メッセージで複数Taskツール呼び出し
✓ WBS/テスト設計: 改善ループ必須
✓ サブエージェント: SUBAGENT_PROMPT_TEMPLATE.md使用

【次のタスク】
{タスク内容}
=====================================
```

## 🔄 各フェーズでの実行パターン

### 1. 要件定義フェーズ
```
📌 ワークフロー再確認出力
→ requirements_analyst 実行（改善ループ最大3回）
→ 成果物: REQUIREMENTS.md
```

### 2. WBS作成フェーズ
```
📌 ワークフロー再確認出力
→ planner 実行（改善ループ最大3回）
→ 成果物: WBS.json
→ 重要: ここでタスク分割の品質が決まる
```

### 3. テスト設計フェーズ
```
📌 ワークフロー再確認出力
→ test_designer 実行（改善ループ最大3回）
→ 成果物: tests/*.test.js
→ 重要: テストの網羅性が実装品質を保証
```

### 4. 実装フェーズ（並列）
```
📌 ワークフロー再確認出力
→ 1メッセージで3つのTaskツール同時呼び出し
   - frontend_dev
   - backend_dev
   - db_expert
```

### 5. 改善ループフェーズ
```
📌 ワークフロー再確認出力
→ evaluator → improvement_planner → fixer → gatekeeper
→ 最大3回繰り返し
```

### 6. 完成処理フェーズ（並列）
```
📌 ワークフロー再確認出力
→ 1メッセージで3つのTaskツール同時呼び出し
   - documenter
   - launcher_creator
   - reviewer
```

## 💡 記憶保持のベストプラクティス

1. **コンテキストが長くなったら**
   - 必ずワークフロー再確認を出力
   - 現在のフェーズと次のタスクを明記

2. **サブエージェント起動時**
   - SUBAGENT_PROMPT_TEMPLATE.md から適切なテンプレート選択
   - プロジェクト名を正確に置換

3. **品質チェック時**
   - テストカバレッジ80%以上を確認
   - 改善ループ実行回数を記録

4. **並列実行時**
   - 必ず1メッセージで複数Taskツール呼び出し
   - 依存関係がないことを確認

## 🚨 よくある記憶劣化パターンと対策

### パターン1: 改善ループを忘れる
**対策**: WBSとテスト設計では必ず3回のループを明示的に実行

### パターン2: 並列実行を逐次実行してしまう
**対策**: 実装フェーズでは必ず1メッセージで複数Task

### パターン3: 品質基準を忘れる
**対策**: 各フェーズ開始時にワークフロー再確認を出力

### パターン4: 作業ディレクトリを間違える
**対策**: ./worktrees/mission-{プロジェクト名}/ を毎回確認

## 📝 チェックリスト（メインエージェント用）

□ CLAUDE.md を読み込んだ
□ WORKFLOW_AUTOMATION_V6.md を読み込んだ
□ SUBAGENT_PROMPT_TEMPLATE.md を読み込んだ
□ 各フェーズでワークフロー再確認を出力している
□ WBS作成で改善ループ3回実行
□ テスト設計で改善ループ3回実行
□ 並列実行は1メッセージで実施
□ 品質基準（カバレッジ80%）を確認している